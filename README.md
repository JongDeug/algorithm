# 알고리즘 학습

알고리즘 공부 및 코딩 테스트를 준비하는 공간입니다.
언어는 JavaScript를 사용하고 있습니다.

## 코딩 테스트 합격자 되기 (복습 큐)

- ~~[모의고사](challenge/golden-rabbit-book/배열/모의고사.js)~~
- ~~[괄호 회전하기](challenge/golden-rabbit-book/스택/괄호%20회전하기.js)~~
- ~~[두 개의 수로 특정 값 만들기](challenge/golden-rabbit-book/해시/두%20개의%20수로%20특정%20값%20만들기.js)~~
- ~~[베스트앨범](challenge/golden-rabbit-book/해시/베스트앨범.js)~~
- ~~[다단계 칫솔 판매](challenge/golden-rabbit-book/트리/다단계%20칫솔%20판매.js)~~
- ~~[미로 탈출](challenge/golden-rabbit-book/트리/미로%20탈출.js) (방식은 맞았는데 한 번더)~~
- ~~[양과 늑대](challenge/golden-rabbit-book/트리/양과%20늑대.js) (생전 처음 보는 BFS 문제 뇌의 확장!)~~
- ~~[길 찾기 게임](challenge/golden-rabbit-book/트리/길%20찾기%20게임.js) (잘 풀었음. 근데 구현 방식만, 배열 or 포인터 좀 더 다듬자)~~
- ~~[간단한 유니온-파인드 알고리즘 구현하기](challenge/golden-rabbit-book/집합/간단한%20유니온-파인드%20알고리즘%20구현하기.js) (경로 압축만)~~
- ~~[주식 가격](challenge/golden-rabbit-book/스택/주식%20가격.js)~~
- ~~[섬 연결하기](challenge/golden-rabbit-book/집합/섬%20연결하기.js)~~
- ~~[벨만-포드 알고리즘](challenge/golden-rabbit-book/그래프/벨만-포드%20알고리즘.js)~~
- ~~[네트워크](challenge/golden-rabbit-book/그래프/네트워크.js) (풀긴 했는데 DFS 로 풀지 않음)~~
- ~~[1부터 N까지 숫자 중 합이 10이 되는 조합 구하기](challenge/golden-rabbit-book/백트래킹/1부터%20N까지%20숫자%20중%20합이%2010이%20되는%20조합%20구하기.js) (좀만 더 숙달)~~
- ~~[카펫](challenge/golden-rabbit-book/시뮬레이션/카펫.js)~~
- [사라지는 발판](challenge/golden-rabbit-book/백트래킹/사라지는%20발판.js) (완벽하게 이해못함... 어렵)
- [지형 이동](challenge/golden-rabbit-book/정렬/지형%20이동.js) (막혀도 몰입해서 끝까지 풀기)
- [배열 회전하기](challenge/golden-rabbit-book/시뮬레이션/배열%20회전하기.js) (공식)
- [롤케이크 자르기](challenge/golden-rabbit-book/시뮬레이션/롤케이크%20자르기.js) (호오..)
- ~~[땅따먹기](challenge/golden-rabbit-book/동적계획법/땅따먹기.js) (풀었지만 다시!)~~
- [도둑질](challenge/golden-rabbit-book/동적계획법/도둑질.js) (어려움)
- ~~[구명보트](challenge/golden-rabbit-book/그리디/구명보트.js) (.......... 점점점점점) 문제를 잘 읽읍시다..~~
- [기지국 설치](challenge/golden-rabbit-book/그리디/기지국%20설치.js) (음.. 나한텐 어려웠음)
- ~~[우선 순위 큐 구현](snippets/data-structure/queue/priority-queue/priority-queue-heap-upgrade.js) (복습)~~
- [다시] ~~[표 편집](challenge/golden-rabbit-book/스택/표%20편집.js)~~
- [다시] ~~[메뉴 리뉴얼](challenge/golden-rabbit-book/해시/메뉴%20리뉴얼.js)~~
- [다시] ~~[다익스트라 알고리즘](challenge/golden-rabbit-book/그래프/다익스트라%20알고리즘.js)~~
- [이거는 BFS랑 dp 섞은 문제임] ~~[경주로 건설](challenge/golden-rabbit-book/그래프/경주로%20건설.js) (마지막 아이디어만 ... 생각할 수 있다면 ...)~~
- [새로운 풀이 복습] ~~[피로도](challenge/golden-rabbit-book/백트래킹/피로도.js) (너무 좋아서 다시 풀기)~~
- [문제를 잘 읽자, 찐막] ~~[양궁 대회](challenge/golden-rabbit-book/백트래킹/양궁%20대회.js) (후.. 저번에도 풀었었지만)~~
- [다시, 구현만 제대로하면 됨, 아이디어는 굳] ~~[외벽 점검](challenge/golden-rabbit-book/백트래킹/외벽%20점검.js) (반복해야됨)~~
- [다시, DFS로 풀어보셈] ~~[달팽이 수열 만들기](challenge/golden-rabbit-book/시뮬레이션/달팽이%20수열%20만들기.js)~~
- [다시, 그냥 외워버려] ~~[가장 큰 수](challenge/golden-rabbit-book/정렬/가장%20큰%20수.js) (오호)~~
- [다시] ~~[가장 큰 정사작형 찾기](challenge/golden-rabbit-book/동적계획법/가장%20큰%20정사각형%20찾기.js) (생각 확장)~~
- [다시] ~~[LCS 길이 계산하기](challenge/golden-rabbit-book/동적계획법/LCS%20길이%20계산하기.js)~~
- [다시] ~~[LIS 길이 계산하기](challenge/golden-rabbit-book/동적계획법/LIS%20길이%20계산하기.js) (풀었지만 다시)~~
- ~~[우선 순위 큐 구현](snippets/data-structure/queue/priority-queue/priority-queue-heap-upgrade.js) (복습)~~
- [다시] ~~[스도쿠 퍼즐](challenge/golden-rabbit-book/백트래킹/스도쿠%20퍼즐.js) (호오) (내일 더 개선, 어떻게 백트래킹 구현할지 감이 안왔음)~~
- [백트래킹은 모아서 다시 풀어보자] ~~[N-퀸](challenge/golden-rabbit-book/백트래킹/N-퀸.js) (호오,,,)~~

## 시간 복잡도, 시간 제한

일반적인 CPU 기반의 PC는 1초에 실행할 수 있는 최대 연산 횟수는 약 100,000,000번

| 시간 복잡도 | 최대 연산 횟수 |
| ----------- | -------------- |
| O(n)        | 약 1억번       |
| O(n^2)      | 약 1만번       |
| O(n^3)      | 약 500번       |
| O(2^n)      | 약 20번        |
| O(n!)       | 10번           |

## Combination 조합

서로 다른 n개의 요소에서 순서와 상관없이 r개를 택한다. `nCr`

```
입력: [1,2,3,4], 3
출력: [ [1,2,3], [1,2,4], [1,3,4], [2,3,4] ]
```

```js
/**
 * 조합(flatMap 버전)
 *
 * @param {*} arr
 * @param {*} selectNumber
 * @returns 조합
 */
const getCombinationsV2 = (arr, selectNumber) => {
  if (selectNumber === 1) return arr.map((value) => [value]);

  return arr.flatMap((fixed, index) => {
    const rest = arr.slice(index + 1);

    return getCombinationsV2(rest, selectNumber - 1).map((comb) => [
      fixed,
      ...comb,
    ]);
  });
};
console.log(getCombinationsV2([1, 2, 3, 4], 3));
```

![image](https://github.com/user-attachments/assets/71c43e9f-c46c-47ba-8e0c-0bd319b221cf)

```js
/**
 * 중복 조합
 *
 * @param {*} arr
 * @param {*} selectNumber
 * @returns 조합 + [1,1], [2,2], [3,3]
 */
const getCombinationsWithRepetition = (arr, selectNumber) => {
  if (selectNumber === 1) return arr.map((value) => [value]);

  return arr.flatMap((fixed, index) => {
    // 전체 배열 중 fixed 미만 요소들을 제외한 나머지
    const rest = arr.slice(index);

    return getCombinationsWithRepetition(rest, selectNumber - 1).map((comb) => [
      fixed,
      ...comb,
    ]);
  });
};
console.log(getCombinationsWithRepetition([1, 2, 3, 4], 3));
```

## Permutation 순열

서로 다른 n개의 요소에서 순서를 고려하면서 r개를 택한다. `nPr`

[1,2] !== [2,1]

```
입력: [1,2,3], 2
출력: [ [1,2], [1,3], [2,1], [2,3], [3,1], [3,2] ]
```

```js
/**
 * 순열(flatMap 버전)
 *
 * flatMap은 arr.map(...args).flat()과 동일
 * @param {*} arr
 * @param {*} selectNumber
 * @returns 순열
 */
const getPermutationsV2 = (arr, selectNumber) => {
  if (selectNumber === 1) return arr.map((value) => [value]);

  return arr.flatMap((fixed, index) => {
    // 현재 요소를 제외한 나머지
    const rest = [...arr.slice(0, index), ...arr.slice(index + 1)];

    // 나머지 요소들로 순열을 만들고 현재 요소를 앞에 붙임
    return getPermutationsV2(rest, selectNumber - 1).map((perm) => [
      fixed,
      ...perm,
    ]);
  });
};
console.log(getPermutationsV2([1, 2, 3, 4], 2));
```

![image](https://github.com/user-attachments/assets/666d7b82-80de-45d4-b48d-2266dcaedc4b)

```js
/**
 * 중복 순열
 *
 * @param {*} arr
 * @param {*} selectNumber
 * @returns 순열 + [1,1], [2,2], [3,3]
 */
const getPermutationsWithRepetition = (arr, selectNumber) => {
  if (selectNumber === 1) return arr.map((value) => [value]);

  return arr.flatMap((fixed) => {
    return getPermutationsWithRepetition(arr, selectNumber - 1).map((perm) => [
      fixed,
      ...perm,
    ]);
  });
};
console.log(getPermutationsWithRepetition([1, 2, 3, 4], 3));
```

## DFS(Depth First Search) 깊이 우선 탐색

인접 노드(1을 기준으로 [2,3])를 언제 방문할지 모르니 **진입 시 방문 처리**

즉, 스택에 푸시할 노드는 방문 '예정'인 노드이므로 팝해서 방문 처리를 해야 함.

![image](https://github.com/user-attachments/assets/dcb16b5f-dd21-496c-acf1-529ae8b17510)

```
입력: { 1: [2,3], 2: [1,4,5], 3: [1], 4: [2], 5: [2] }, 1
출력: [ 1, 3, 2, 5, 4 ]
```

```js
/**
 * DFS(while)
 *
 * @param {*} graph
 * @param {*} start
 * @returns LIFO 특성 때문에 같은 레벨이면 마지막에 들어간 놈이 먼저 표시됨
 */
const dfsV1 = (graph, start) => {
  const visited = new Set();
  const stack = [start];
  const result = [];

  while (stack.length) {
    const node = stack.pop();

    if (!visited.has(node)) {
      visited.add(node);
      result.push(node);

      for (const neighbor of graph[node]) {
        if (!visited.has(neighbor)) {
          stack.push(neighbor);
        }
      }
    }
  }

  return result;
};
console.log(dfsV1(graph, start));
```

```
입력: { 1: [2,3], 2: [1,4,5], 3: [1], 4: [2], 5: [2] }, 1
출력: [ 1, 2, 4, 5, 3 ]
```

```js
/**
 * DFS(재귀)
 *
 * @param {*} graph
 * @param {*} start
 * @returns 재귀 특성 때문에 먼저 진입한 놈이 먼저 표시됨
 */
const dfsV2 = (graph, start) => {
  const result = [];
  const visited = new Set();

  const dfsHelper = (node) => {
    if (visited.size === graph.length) return;

    if (!visited.has(node)) {
      visited.add(node);
      result.push(node);

      for (const neighbor of graph[node]) {
        if (!visited.has(neighbor)) {
          dfsHelper(neighbor);
        }
      }
    }
  };
  dfsHelper(start);

  return result;
};
console.log(dfsV2(graph, start));
```

## BFS(Breadth First Search), 너비 우선 탐색

큐에 푸시할 노드는 다음 방문할 노드이므로 바로 방문 처리, 스택과 다름.

![image](https://github.com/user-attachments/assets/dcb16b5f-dd21-496c-acf1-529ae8b17510)

```
입력: { 1: [2,3], 2: [1,4,5], 3: [1], 4: [2], 5: [2] }, 1
출력: [ 1, 2, 3, 4, 5 ]
```

```js
/**
 * BFS(while)
 *
 * @param {*} graph
 * @param {*} start
 * @returns
 */
const bfs = (graph, start) => {
  const queue = [start];
  const result = [];
  const visited = new Set([start]);

  while (queue.length) {
    const node = queue.shift();
    result.push(node);

    for (const neighbor of graph[node]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }

  return result;
};
console.log(bfs(graph, start));
```

## Stack 스택

배열 활용, O(1)

```js
/**
 * 배열을 활용한 스택
 *
 * 시간 복잡도 O(1)
 */
const stack = [];
stack.push(1);
stack.pop();
```

![image](https://github.com/user-attachments/assets/88377cfc-2359-40df-9e8f-2bd40141c8c1)

```js
/**
 * 단일 연결 리스트를 활용한 스택
 *
 * 시간 복잡도 O(1)
 */
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Stack {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }

  push(value) {
    const node = new Node(value);

    if (!this.head) {
      this.head = node;
      this.tail = node;
    } else {
      node.next = this.head;
      this.head = node;
    }
    this.size++;
  }

  // tail에서 pop하려면 양방향 연결 리스트로 구현해야 돼서 복잡해짐
  pop() {
    if (!this.head) return null;

    const removed = this.head;

    if (this.size === 1) this.head = this.tail = null;
    else {
      this.head = removed.next;
      removed.next = null;
    }
    this.size--;
    return removed.value;
  }
}
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
stack.push(4);

console.log(stack.pop());
console.log(stack.pop());
console.log(stack.pop());
console.log(stack.pop());
console.log(stack.pop());
```

## Queue 큐

배열 활용, O(n)

```js
/**
 * 배열을 활용한 큐
 *
 * 시간 복잡도 O(n)
 */
const queueV1 = [];
queueV1.push(1); // enqueue
queueV1.shift(); // dequeue
```

배열 활용, O(1)

![image](https://github.com/user-attachments/assets/cc842867-9b0c-4b0a-a941-a9ebc753a0c2)

```js
/**
 * 배열을 활용한 큐
 *
 * 시간 복잡도 O(1)
 */
class QueueV2 {
  constructor() {
    this.item = [];
    this.front = -1;
    this.rear = -1;
  }

  enqueue(value) {
    this.item.push(value);
    this.rear++;
  }

  dequeue() {
    if (this.isEmpty()) return null;
    return this.item[++this.front];
  }

  isEmpty() {
    return this.front === this.rear;
  }
}
const queueV2 = new QueueV2();
queueV2.enqueue(1);
queueV2.enqueue(2);
queueV2.enqueue(3);
queueV2.enqueue(4);

console.log(queueV2.dequeue());
console.log(queueV2.dequeue());
console.log(queueV2.dequeue());
console.log(queueV2.dequeue());
console.log(queueV2.dequeue());
```

단일 연결 리스트 활용, O(1)

![image](https://github.com/user-attachments/assets/0f9d6844-0981-402e-a9e1-30a947d8ffb6)

```js
/**
 * 단일 연결 리스트를 활용한 큐
 *
 * 시간 복잡도 O(1)
 */
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class QueueV3 {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }

  enqueue(value) {
    const node = new Node(value);

    if (!this.head) {
      this.head = node;
      this.tail = node;
    } else {
      this.tail.next = node; // 현재 tail의 next
      this.tail = node; // 앞으로의 tail
    }
    return ++this.size;
  }

  dequeue() {
    if (!this.head) return null;

    const removed = this.head;

    if (this.size === 1) this.head = this.tail = null;
    else {
      this.head = removed.next;
      removed.next = null;
    }
    this.size--;

    return removed.value;
  }
}
const queueV3 = new QueueV3();
queueV3.enqueue(1);
queueV3.enqueue(2);
queueV3.enqueue(3);
queueV3.enqueue(4);

console.log(queueV3.dequeue());
console.log(queueV3.dequeue());
console.log(queueV3.dequeue());
console.log(queueV3.dequeue());
console.log(queueV3.dequeue());
```

## Bubble Sort, 버블 정렬

인접한 요소 쌍끼리 비교해 조건에 맞게 정렬하는 방법

- **Inner Loop**: 배열의 첫 번째 인덱스부터 차례대로 인접한 요소끼리 비교해 swap
- **Outer Loop**: 정렬된 요소를 제외하고 반복

![Pasted image 20240312185339](https://github.com/user-attachments/assets/cca73087-1806-4a7e-a1f2-3e64ab57769c)

```js
const swap = (arr, i, j) => {
  return ([arr[i], arr[j]] = [arr[j], arr[i]]);
};

/**
 * 버블 정렬
 *
 * 최적화 x, 최악 O(n^2)
 * @param {*} arr
 * @returns
 */
const bubbleSortV1 = (arr) => {
  // Outer Loop : 배열의 크기 - 1 만큼
  for (let i = arr.length - 1; i > 0; i--) {
    // Inner Loop : 인접한 요소끼리 비교 후 swap
    for (let j = 0; j < i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1);
      }
    }
  }
  return arr;
};
console.log(bubbleSortV1([8, 3, 1, 5, 6, 7]));

/**
 * 버블 정렬
 *
 * 최적화 o, 특정 조건에서 O(n)
 * @param {*} arr
 */
const bubbleSortV2 = (arr) => {
  for (let i = arr.length - 1; i > 0; i--) {
    let noSwap = true;
    for (let j = 0; j < i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1);
        noSwap = false;
      }
    }
    // swap이 한 번도 이뤄지지 않았다면 종료
    if (noSwap) break;
  }
  return arr;
};
console.log(bubbleSortV2([8, 3, 1, 5, 6, 7]));
```

## Selection Sort, 선택 정렬

오름차순일 경우 가작 작은 요소를 찾아 배열의 처음부터 순서대로 쌓아가며 정렬하는 방법

- **Inner Loop**: 배열에서 가장 작은 값의 Index를 찾음
- **Outer Loop**: 정렬되지 않은 배열에서 가장 처음 요소와 minIdx값을 swap, 이 과정을 반복

![Pasted image 20240314185519](https://github.com/user-attachments/assets/98d3b6af-9d1f-4463-80e2-947c63637352)

```js
const swap = (arr, i, j) => {
  return ([arr[i], arr[j]] = [arr[j], arr[i]]);
};

/**
 * 선택 정렬
 *
 * 최악 O(n^2)
 * @param {*} arr
 * @returns
 */
const selectionSort = (arr) => {
  // Outer Loop : 배열의 크기 - 1 만큼
  for (let i = 0; i < arr.length - 1; i++) {
    let minIdx = i;
    // Inner Loop: 가장 작은 값의 인덱스를 찾는다.
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIdx]) minIdx = j;
    }
    if (minIdx !== i) swap(arr, i, minIdx);
  }
  return arr;
};
console.log(selectionSort([8, 3, 1, 5, 6, 7]));
```

## Insertion Sort, 삽입 정렬

배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고,
정렬되지 않은 부분의 원소를 하나씩 적절한 위치에 삽입하면서 정렬하는 방법

![Pasted image 20240315185444](https://github.com/user-attachments/assets/0beba147-80d7-44e1-b42c-28c04cc3432a)

- **Inner Loop**: 특정 요소를 정렬된 부분의 적절한 위치에 삽입
- **Outer Loop**: 이 과정을 반복

![Pasted image 20240318172232](https://github.com/user-attachments/assets/c73e88fe-1076-48fa-9a84-f4d28e4866b8)

```js
const swap = (arr, i, j) => {
  return ([arr[i], arr[j]] = [arr[j], arr[i]]);
};

/**
 * 삽입 정렬
 *
 * 최악 O(n^2)
 * @param {*} arr
 * @returns
 */
const insertionSortV1 = (arr) => {
  // Outer Loop : 배열의 크기 - 1 만큼
  for (let i = 1; i < arr.length; i++) {
    // Inner loop : 2번째 요소부터 시작해 left side에 적절한 위치를 찾는다.
    for (let j = i; j >= 0; j--) {
      if (arr[j] < arr[j - 1]) swap(arr, j, j - 1);
      else break;
    }
  }
  return arr;
};
console.log(insertionSortV1([8, 3, 1, 5, 6, 7]));
```
